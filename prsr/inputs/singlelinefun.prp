

# If a function call calls a method, the called method can not have arguments.
# If arguments must be passed to the nested method, all the methods (calling
# and nested) must use parenthesis to be explicit.

fun ::
  puts "a"
end

fun b ::
  puts "a"
end

fun(b,::
  puts "a"
end)

fun(c(::
  puts "a"
end))

# b is different from c


############
fun a b ::
  puts "a"
end

fun (a,b, ::
  puts "a"
end)

############

fun(a,(b ::
  puts "a"
end))

fun  a b ::
  puts "a"
end

fun((a,b),(c,d))

puts(a(+1))

puts a +1 # same as puts a + 1

#############################


a = (1 2 3 4 5).map :: 
  ${0} == 0
end

a = (1 2 3 4 5).map :: ${0} == 0
end

a = (1 2 3 4 5).map :: ${0} == 0; end
a = (1 2 3 4 5).map(:: ${0} == 0; end)
a = (1 2 3 4 5).map(::${0}==0;end)
a = (1 2 3 4 5).map(   ::${0}==0;end
)

a = (1 2 3 4 5).map(;;;;::${0}==0;;;;;end;;;;)
a = (1 2 3 4 5).map(;;


;;::${0}==0
;;
;;;end;;

;;)


funccall :: a = 1
 b = 3
end

funccall :: a = 1 ; b = 3; end

if a == 3
  puts "a"
end

if a == 3
  puts "a"
else puts "x"
end

if a == 3 ; puts "a" ; end

if a == 3 ; puts "a" ; else puts "b" ; end

# Guaranteed beginning of new statement after "::" and "else" and "end"


#######################
try :: a = 1
 b = 3
else
 b = 1
end

try :: a = 1; b = 3; else b = 1; end 

#######################

f = 3 ; v = 4;

a = 3

f = 3 
v = 4

a =3

