
(* Pyrope grammar with preparse to remove comments and create tokens *)
(* New lines and ';' are line separator. In lexer, "((\n|\r|;)+[space])+ -> newline_ *)
(* Commas are list separators. In lexer ",[space|newline_]," -> ","  *)
(* Some tokens change when at the beginning of new line. In lexer (newline_|';'), [,+*/|&^ and or] -> n_comma n_+ n_* n_or n_and ... *)
(* To distinguish between 1+1 * 3 and 1 + 1*3, The +/* tokens also have s_+ (spaced +) or t_+ (tight +) *)
(* In the grammar: '+' means s_+ | t_+ | n_+ *)
(* newline_s that have no meaning are eliminated. E.g: (newline_|';'), [,:=] -> [,:=] *)
(* In lexer, token 'not' 'in' becomes 'notin' *)
(* In lexer, token 'is' 'not'  becomes 'isnot' *)
(* In lexer, Token '|>' becomes "pipe" *)
(* Spaces are Token separators. As usual, no token for spaces *)

(*

 Grammar rules are simple to help tree creation: After removing the "tokens",
 each rule has a fixed number of sub-rules.  If the rule has a repeat or skip,
 there is nothing but the repeat/skip after removing the tokens. The reason is
 that this allows to have tree nodes of fixed size (easier to convert to ASTs)
 or a simple repetition pattern

*)

stmt_seq
  = {stmt}
  ;

stmt
  = (if_stmt
    | match_stmt
    | while_stmt
    | for_stmt
    | ass_fcall_stmt
    | ctrl_stmt
    | scope_stmt_seq
    | try_stmt
    | debug_comptime_stmt
    | yield_stmt
    | fail_stmt
    | test_stmt)
  , gate_stmt_opt, newline_
  ;

gate_stmt_opt
  = [('when' | 'unless'), expr_entry]
  ;

if_stmt
  = ['unique'], 'if', expr_entry, scope_stmt_seq, if_elif_seq, else_line_opt
  ;

else_line_opt
  = ['else', scope_stmt_seq]
  ;

if_elif_seq
  = {if_elif_line}
  ;

if_elif_line
  = 'elif', expr_entry, scope_stmt_seq
  ;

(* after '}' there must be a newline_ or a when or an unless, but already in
   other rules.  If possible to "peek" it could be checked *)
scope_stmt_seq
  = '{', newline_, stmt_seq, '}'
  ;

scope_stmt_opt
  = [scope_stmt_seq]
  ;

debug_comptime_stmt
  = stmt_attr, scope_stmt_seq
  ;

stmt_attr
  = (('comptime', ['debug']) | 'debug')
  ;

stmt_attr_opt
  = [stmt_attr]
  ;

test_stmt
  = 'test', LITERAL_STRING, scope_stmt_seq
  ;

fail_stmt
  = 'fail', LITERAL_STRING, scope_stmt_seq
  ;

try_stmt
  = 'try', scope_stmt_seq, else_line_opt
  ;

yield_stmt
  = 'yield', expr_entry_opt, scope_stmt_opt
  ;

match_stmt
  = 'match', bundle_list, '{', newline_, match_stmt_line_seq, match_else_line_opt, '}'
  ;

match_stmt_line_seq
  = {match_factor_line}
  ;

match_stmt_line
  = (is_typecase | in_range | expr_entry), gate_stmt_opt, scope_stmt_seq, newline_
  ;

match_else_line_opt
  = ['else', scope_stmt_seq, newline_]
  ;

while_stmt
  =  'while', expr_entry, scope_stmt_seq
  ;

for_stmt
  =  'for', identifier, in_range, scope_stmt_seq
  ;

ctrl_stmt
  = 'continue' | 'break' | 'return'
  ;

(* default pass is "let" "comb" *)
ass_fcall_stmt
  = assign_attr_opt
  , variable_base, (assignment_cont | ass_fcall_func_cont | bundle_list)
  ;

ass_fcall_func_cont
  = fcall_args, fcall_pipe_seq
  ;

fcall_args
  = bundle, fcall_args_lambda_opt
  ;

fcall_args_lambda_opt
  = [pipe_check_opt, lambda_def, fcall_args_lambda_else_opt]
  ;

fcall_args_lambda_else_opt
  = ['else', pipe_check_opt, lambda_def ]
  ;

fcall_pipe_seq
  = {fcall_pipe}
  ;

fcall_pipe
  = [newline_], '|>', variable_base, fcall_args
  ;

assign_attr_opt
  = [(stmt_attr_opt, 'let', let_attr_opt) | 'mut' | 'var' | 'set']
  ;

let_attr_opt
  = [pipe_check | repipe_check | 'type']
  ;

assignment_cont
  = typecase_opt, [newline_], ('=' | ':=' | '+=' | '-=' | '++=' | '|=' | '&=' | '^=' | '*=' | '/='), bundle_list
  ;


pipe_check
  = (('pipe' | 'async'), '(', range, ')' | 'anypipe')
  ;

pipe_check_opt
  = [pipe_check]
  ;

repipe_check
  = ('repipe' | 'reasync'), '(', range, ')'
  ;

(* variable_base has no fluid or bit operations @ *)
typecase
  = ':', [(variable_base|literal|bundle), where_opt]
  ;

where_opt
  = ['where', lambda_def]
  ;

typecase_opt
  = [typecase]
  ;

is_typecase
  = ('is' | 'isnot'), typecase
  ;

variable_base
  = variable_base_start
   ,variable_base_field_seq
   ,variable_prev_field_opt
   ,variable_base_last_opt
  ;

variable_base_start
  = (('$' | '%' | '#'), [(identifier|literal)] | identifier)
  ;

variable_base_last_opt
  = ['?' | '!' | variable_bit_sel_seq]
  ;

variable_prev_field_opt
  = ['#','[', [newline_], expr_entry, [newline_], ']']
  ;

variable_base_field_seq
  = {variable_base_field}
  ;

variable_base_field
  = ['?'] , (dot_selector | selector)
  ;

dot_selector
  = [newline_], '.', (identifier|literal)
  ;

selector
  = '[', expr_seq, [newline_], ']'
  ;

bundle
  = '(', bundle_seq, [newline_], ')', typecase_opt
  ;

expr_seq
  = comma_seq_, {expr_entry, {comma, comma_seq_, expr_entry}}, comma_seq_
  ;

bundle_seq
  = comma_seq_, {bundle_entry, {comma, comma_seq_, bundle_entry}}, comma_seq_
  ;

bundle_list
  = bundle_entry, {comma, comma_seq_, bundle_entry}
  ;

comma_seq_
  = {comma}
  ;

comma
  = [newline_], ','
  ;

(* if = hits, 1st factor can be only "identifier typecase_opt" *)
bundle_entry
  = factor, [ '=', factor], expr_cont_seq
  ;

expr_entry
  = factor , expr_cont_seq
  ;

expr_entry_opt
  = [expr_entry]
  ;

(* all the operator (+,*,/...) have + and newline__+ *)
expr_cont
  = (('++' | '+' | '*' | '/' | '|' | '&' | '^' | 'or' | 'and' | 'has' | 'implies' | '<' | '<=' | '==' | '!=' | '>=' | '>'), factor)
  | is_typecase
  | in_range
  | fcall_pipe
  ;

expr_cont_seq
  = {expr_cont}
  ;

factor_opt
  = [factor]
  ;

factor
  = stmt_attr_opt, ['!' | '-' | '~']
  , ( factor_var_fcall_type
    | literal
    | bundle
    | if_expr
    | match_expr
    | lambda_def
  )
  ;

factor_var_fcall_type
  = variable_base, [fcall_args | typecase]
  ;

if_expr
  = 'if', expr_entry, '{', expr_entry, '}', 'else', '{', expr_entry, '}'
  ;

match_expr
  = 'match', bundle_list, '{', match_factor_line_seq, match_expr_else_opt, '}'
  ;

match_expr_else_opt
  = [[newline_], 'else', '{', expr_entry, '}']
  ;

variable_bit_sel_seq
  = {variable_bit_sel}
  ;

variable_bit_sel
  = '@', ['sext' | 'zext' | '|' | '&' | '^' | '+'], selector
  ;

match_factor_line_seq
  = {match_factor_line}
  ;

match_factor_line
  = [newline_], (is_typecase | in_range | expr_entry), gate_stmt_opt, '{', expr_entry, '}'
  ;

range
  = factor_opt, (':' | '+:' | '..'), factor_opt, range_step_opt
  ;

range_step_opt
  = [':', factor]
  ;

in_range
  = ('in' | 'notin'), range
  ;

lambda_def
  = '{|', (newline_, stmt_seq | expr_entry), '}'
  ;

(* multiline string
  a = "multi\n
   ++ "  line\n"
   ++ "string"
*)

literal
  = LITERAL_INTEGER
  | LITERAL_STRING
  | LITERAL_BOOLEAN
  ;

LITERAL_INTEGER
  = '0b',  ('0'|'1'|'?'), {'_'|'0'|'1'|'?'}
  | '0sb', ('0'|'1'|'?'), {'_'|'0'|'1'|'?'}
  | '0o',  ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'), {'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'}
  | '0x',  ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'A'|'b'|'B'|'c'|'C'|'d'|'D'|'e'|'E'|'f'|'F'), {'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'A'|'b'|'B'|'c'|'C'|'d'|'D'|'e'|'E'|'f'|'F'}
  | '0sx',  ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'A'|'b'|'B'|'c'|'C'|'d'|'D'|'e'|'E'|'f'|'F'), {'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'A'|'b'|'B'|'c'|'C'|'d'|'D'|'e'|'E'|'f'|'F'}
  | ('1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'), {'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'}
  ;

LITERAL_STRING
  = "'", STRING1_SEQ, "'"
  | '"', STRING2_SEQ, '"'
  ;

LITERAL_BOOLEAN
  = 'true' | 'false'
  ;

STRING1_SEQ
  = {"^'\n"}
  ;
STRING2_SEQ
  = {'^"\n'}
  ;

