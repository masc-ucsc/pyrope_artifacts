
(* Pyrope grammar with preparse to remove comments and create tokens *)
(* New lines and ';' are line separator. In lexer, "((\n|\r|;)+[space])+ -> newline *)
(* Commas are list separators. In lexer ",[space|newline]," -> ","  *)
(* Some tokens change when at the beginning of new line. In lexer (newline|';'), [,+*/|&^ and or] -> n_comma n_+ n_* n_or n_and ... *)
(* To distinguish between 1+1 * 3 and 1 + 1*3, The +/* tokens also have s_+ (spaced +) or t_+ (tight +) *)
(* In the grammar: '+' means s_+ | t_+ | n_+ *)
(* Newlines that have no meaning are eliminated. E.g: (newline|';'), [,:=] -> [,:=] *)
(* In lexer, token 'not' 'in' becomes 'notin' *)
(* In lexer, token 'is' 'not'  becomes 'isnot' *)
(* In lexer, Token '|>' becomes "pipe" *)
(* Spaces are Token separators. As usual, no token for spaces *)
(* constant and string are the same? *)

start
  = {stmt}
  ;

stmt
  = stmt_itself, [gate_stmt], newline
  ;

gate_stmt
  = ('when' | 'unless'), bool_expr
  ;

stmt_itself
  = if_stmt
  | while_stmt
  | for_stmt
  | ass_fcall_stmt
  | ctrl_stmt
  ;

if_stmt
  = ['unique'], 'if', ['comptime'], bool_expr, new_scope, {'elif', ['comptime'], bool_expr, new_scope}, ['else', new_scope]
  ;

while_stmt
  =  'while', ['comptime'], bool_expr, new_scope
  ;

for_stmt
  =  'for', ['comptime'], identifier, 'in', tup_expr_list, new_scope
  ;

ctrl_stmt
  = 'continue' | 'break' | 'return'
  ;

ass_fcall_stmt
  = assign_attribute, variable_base, assignment_cont
  | ['comptime'], variable_base, (assignment_cont | (fcall_args | tup_expr_list), {'|>', fcall_stmt})
  ;

assign_attribute
  = ('let' | 'mut' | 'var' | 'set' | 'raw'), (
   [('pipe' | 'comb')], ['comptime']
   | ['type']
  )
  ;

fcall_stmt
  = variable_base, fcall_args, {'|>', fcall_stmt}
  ;

(* this can only happen when "mut xx +=..." or " xx +=..." *)
assignment_cont
  = [typecase], ('=' | ':=' | '+=' | '-=' | '++=' | '|=' | '&=' | '^=' | '*=' | '/='), tup_expr_list
  ;

fcall_args
  = '(', [expr_list], ')', [fcall_def, ['else', new_fun_scope]]
  ;

typecase
  = ':', variable_base, ['constrain', new_fun_scope]
  ;

variable_base
  = ['$' | '%' | '#'], identifier, {'.', (identifier|constant) | '[', expr_list, ']'}
  ;

variable_bit_sel
  = '@', ['sext' | 'zext' | '|' | '&' | '^' | '+'], '(', [expr_list], ')'
  ;

expr_list
  = expr_element, { ',', expr_element}
  ;

(* if '=' the factor can only be identifier [typecase] *)
expr_element
  = {','}, ['comptime'], factor, ( '=' | tup_expr_cont)
  ;

tup_expr
  = factor, {tup_expr_cont|scalar_expr_cont|bool_expr_cont}
  ;

tup_expr_list
  = tup_expr, {',', tup_expr}
  ;

tup_expr_cont
  = ('++' | 'in' | 'notin'), factor
  | 'between', range
  | range_cont
  ;

scalar_expr
  = factor, {scalar_expr_cont|bool_expr_cont}
  ;

scalar_expr_cont
  = ('+' | '*' | '/' | '|' | '&' | '^'), factor
  | '|>', fcall_stmt
  ;

bool_expr
  = factor, {bool_expr_cont}
  ;

bool_expr_cont
  = ('or' | 'and' | 'implies' | 'is' | 'isnot' | '<' | '<=' | '==' | '!=' | '>=' | '>'), factor
  ;

factor
  = ['!' | '-' | '~'], (variable_base, [variable_bit_sel | fcall_args | typecase]
    | constant
    | '(', [expr_list], ')', [typecase]
    | 'if', bool_expr, '{', tup_expr_list, '}', 'else', '{', tup_expr_list, '}'
    | fcall_def
  )
  ;

range
  = [factor], range_cont
  ;

range_cont
  = (':' | '..'), [factor], ['step', factor]
  ;

fcall_def
  = '|', [ '(', {','}, {'$', identifier}, {','} ')'], '|', new_fun_scope
  ;

new_fun_scope
  = '{', (newline, {stmt} | tup_expr_list), '}'
  ;

new_scope
  = '{', newline, {stmt}, '}'
  ;
