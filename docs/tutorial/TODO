
----

Anything all uppercase is an automatic constant in current scope. No need to assign Id, created unique I'd by pyrope.

a = 3
If a == FOO // compile error, previous a was not auto const
  x = BAR
  If x == FOOOO // ok, but always false


----

foo.prp
foo.vow

 The vow file is a Pyrope pass that runs only when "vow" pass is enabled too. Runtime/compile time checks for the IOs/registers in prp

 Vow file can read any state, but not update state in prp, just in vow file

----


Encapsulation vs modules

 -Encapsulation is just for objects.

 -We do modules like in Python. Starting with foo vs _foo the _foo is private,
not enforced to be private if you want to access. Just do not do it.

==========
Expand the DP explanation to include this example (DP is syntax sugar in a way)

// lhs := rhs
if rhs.__max > lhs.__max {
   lhs = lhs.max
}elif rhs.__min < lhs.__min {
   lhs = lhs.min
}else{
   lhs = rhs
}

==========
Jupiter notebook for LNAST? Pyrope?


-----

Async like with fluid?

 send = ::{
    %out.__fluid = true
    %out = $0 + 1
 }

 @local_cntr.__bits = 3
 @local_cntr := @local_cntr + 1

 z = xx.send(@local_cntr)
 if z.out? { // if z? is the same
  I(@local_cntr == 1 -> z.out==0)
  I(@local_cntr == 2 -> z.out==1)
 }


 xx.send(@local_cntr) |> ::{
   if $out? {
      // $out? is the z.out, but @local_cntr is not visible
   }
 }

 tmp = @local_cntr
 tmp._cntr = @local_cntr
 z = xx.send(tmp)
 if z.out? {
   I(@local_cntr == 1 -> z._cntr==0 and z.out==0)
 }

----

Create a website with markdown?
https://github.com/tomjoht/documentation-theme-jekyll
Ideally, same markdown can be used for a book

--------

try {
  a = $input
}else{
  a = 3
}

if $input? {
  a = $input
}else{
  a = 3
}

try {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

if $input? and $inp2? and ($input!=0 or $inp3?) {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

try = ::{
   if bla bla {
     %a = 3
   }
}

test1 = ::{
  %a = 3
}

a = 0
x = test1
I x.a==3 and a==0

//---------------
// We discarded long time ago, weird "= foo ". Uncommon in other lang
test1 = ::{
  %a = 3
}

a = 0
= test1
I a==3

//--------------
test1 = ::{
  %a = 3
}

a = 0
test1
I a==3

-------
map as ::{
  t = ()
  fun = $.__block
  for a in $ {
    t ++= fun(a)
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (1 2 3) |> map ::{$+1} |> map ::{$*$}
I s == (4 9 16)

-------
map as ::{
  t = ()
  fun = $.__block
  for a:$ {
    t ++= fun a
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (x 2 3) |> map ::{$+1} |> map ::{$*$}
I s == ((x+1)*(x+1) 9 16)

// TODO: This is a compile error (# inputs is unknown at compile time)
s = $x ** (1 2 3) |> map ::{$+1} |> map ::{$*$}


==========================
CHISEL example library (PrefixSum) to do tree reduction

prefix_reduction = ::{
  total = $0
  for i in $[1..] {
    total = $.__do(total,i)
  }

  return total
}

total = (1 2 3 4) |> prefix_reduction ::{ $0 + $1 }

------
Go over KoggeStoneAdder in CHISEL and do the equivalent in Pyrope to see
(Latchup.io Jack talk on CHISEL 3)

------
Go over sparse prefix sum in CHISEL and Pyrope

------
Add example:

doadd = ::{ $0 + $1 }
reduce = ::{
  total = $1
  for i:$[2..] {
    total = $0(total, i)
  }
  return total
}
total = (1 2 3 4) |> reduce \doadd
I total == 10

------

dec_large = ::{
  for a in $ {
    if (#[0](a)) {      // #.0 == #[0]
      % ++= #.potato(a) // #.1 == #.potato
    }else{
      % ++= a
    }
  }
}

(1, 2, 3) |> dec_large ::{ $0 > 3 } potato { $0-1 }

