
try {
  a = $input
}else{
  a = 3
}

if $input? {
  a = $input
}else{
  a = 3
}

try {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

if $input? and $inp2? and ($input!=0 or $inp3?) {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

try = ::{
   if bla bla {
     %a = 3
   }
}

test1 = ::{
  %a = 3
}

a = 0
x = test1
I x.a==3 and a==0

//---------------
// We discarded long time ago, weird "= foo ". Uncommon in other lang
test1 = ::{
  %a = 3
}

a = 0
= test1
I a==3

//--------------
test1 = ::{
  %a = 3
}

a = 0
test1
I a==3

-------
map as ::{
  t = ()
  fun = $.__block
  for a in $ {
    t ++= fun(a)
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (1 2 3) |> map ::{$+1} |> map ::{$*$}
I s == (4 9 16)

-------
map as ::{
  t = ()
  fun = $.__block
  for a:$ {
    t ++= fun a
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (x 2 3) |> map ::{$+1} |> map ::{$*$}
I s == ((x+1)*(x+1) 9 16)

// TODO: This is a compile error (# inputs is unknown at compile time)
s = $x ** (1 2 3) |> map ::{$+1} |> map ::{$*$}


==========================
CHISEL example library (PrefixSum) to do tree reduction

prefix_reduction = ::{
  total = $0
  for i:$[1..] {
    total = $.__block total i
  }

  return total
}

total = (1 2 3 4) |> prefix_reduction ::{ $0 + $1 }

------
Go over KoggeStoneAdder in CHISEL and do the equivalent in Pyrope to see
(Latchup.io Jack talk on CHISEL 3)

------
Go over sparse prefix sum in CHISEL and Pyrope

------
Add example:

doadd = ::{ $0 + $1 }
reduce = ::{
  total = $1
  for i:$[2..] {
    total = $0(total, i)
  }
  return total
}
total = (1 2 3 4) |> reduce \doadd
I total == 10

------

dec_large = ::{
  for a in $ {
    if (#[0](a)) {      // #.0 == #[0]
      % ++= #.potato(a) // #.1 == #.potato
    }else{
      % ++= a
    }
  }
}

(1, 2, 3) |> dec_large ::{ $0 > 3 } potato { $0-1 }

