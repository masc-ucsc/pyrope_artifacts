
--------------
ADD THIS CONCAT EXAMPLE TO TUTORIAL:

a = "hello"

if true {
 a = a ++ ".banana"
}

b = ("hello", ".banana")

val = 0
if b[0] == a[0] and a[1] == b[1] and a==b { // TRUE
  val = 0x23
}

if "hello.banana" == a or b == "hello.banana" { // FALSE
  val = 0xdead
}

if a@() == "hello.banana" and b@() == "hello.banana" { // TRUE
  val = val + 0x10
}

tmp = 3 ++ 5           // (3,5)
x = tmp[0] + tmp[1]    // 3+5
x2 = tmp@()            // 0b011 ++ 0b0101 == 0b011_0101 == 0x35
%total = x + x2        // 8+0x35 = 0x3d

foo[a@()] = 3
%out = foo.hello.banana + val // 3 + 0x33 == 0x36


//-----------------------------

a = 3     // immutable

b = (1,3) // immutable

mut c.b = 3 // mutable

c.c = 3 // compile error
set c.b = 1 // set value, no mutate object
set c.d = 1 // compile error: d field does not exit
mut c.d = 1 // OK

mut d.foo.__bits = 3
set d.foo := 1   // change val, drop bits if needed
set d.bar := 1   // compile error: bar field does not exit

e := 3       // compile error: e does not exist


//------ What about?

val (optional/required) for immutable variables.

val a = 3

--------------------------

We are building a programming language for hardware, and we are thinking
about adding keywords for mutable/immutable/add_field assignments.

The language uses a "prototypal-like" inheritance. Something like this is possible.

a.foo = 3  // no previous 'a' declaration
fcall(a)   // same as fcall(foo=3)

a.bar = 4
fcall(a)   // same as fcall(foo=3,bar=4)

The proposed mutable/immutable keywords:

var foo.xx = ... // first instance of foo.xx and it is mutable
let foo.xx = ... // first instance of foo.xx and it is immutable

set foo.xx = ... // modifies foo.xx (xx must exist)
mut foo.yy = ... // modifies foo.yy (yy may not exist)

The language/compiler can handle without the var/set/set/mut keywords, but they
can be useful to catch errors like unintended setting a non-existing field.

Any suggestion?

------------------------------------

-Compile time directives:

guard cond  : prevents the method being called unless guards are true. Must be evaluated at compile time
expect cond : compile time checks (unlike guard there is no code side effects)
infer cond  : allow to simplify code based on the condition, checks at run-time for it

guard foo is static // know at compile time
guard foo is const  // can not change at runtime

expect foo is const // compile time check

infer foo == xxx    // check runtime/compile and simplify code

-Runtime directives:

assert foo is const // same as expect, but method could be called and checked at runtime
cover  foo          // coverage point

-Format verification checks

assume foo == 3 // eq: to verilog assume
restrict foo == 3 // runtime/synthesis assumptions (checked during simulation)

----

Anything all uppercase is an automatic constant in current scope. No need to assign Id, created unique I'd by pyrope.

a = 3
If a == FOO // compile error, previous a was not auto const
  x = BAR
  If x == FOOOO // ok, but always false


----

foo.prp
foo.vow

 The vow file is a Pyrope pass that runs only when "vow" pass is enabled too. Runtime/compile time checks for the IOs/registers in prp

 Vow file can read any state, but not update state in prp, just in vow file

----


Encapsulation vs modules

 -Encapsulation is just for objects.

 -We do modules like in Python. Starting with foo vs _foo the _foo is private,
not enforced to be private if you want to access. Just do not do it.

==========
Expand the DP explanation to include this example (DP is syntax sugar in a way)

// lhs := rhs
if rhs.__max > lhs.__max {
   lhs = lhs.max
}elif rhs.__min < lhs.__min {
   lhs = lhs.min
}else{
   lhs = rhs
}

==========
Jupiter notebook for LNAST? Pyrope?


-----

Async like with fluid?

 send = ::{
    %out.__fluid = true
    %out = $0 + 1
 }

 @local_cntr.__bits = 3
 @local_cntr := @local_cntr + 1

 z = xx.send(@local_cntr)
 if z.out? { // if z? is the same
  I(@local_cntr == 1 -> z.out==0)
  I(@local_cntr == 2 -> z.out==1)
 }


 xx.send(@local_cntr) |> ::{
   if $out? {
      // $out? is the z.out, but @local_cntr is not visible
   }
 }

 tmp = @local_cntr
 tmp._cntr = @local_cntr
 z = xx.send(tmp)
 if z.out? {
   I(@local_cntr == 1 -> z._cntr==0 and z.out==0)
 }

----

Create a website with markdown?
https://github.com/tomjoht/documentation-theme-jekyll
Ideally, same markdown can be used for a book

--------

try {
  a = $input
}else{
  a = 3
}

if $input? {
  a = $input
}else{
  a = 3
}

try {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

if $input? and $inp2? and ($input!=0 or $inp3?) {
  a = $input + $inp2
  c = $input!=0 or $inp3
}else{
  a = 3
}

try = ::{
   if bla bla {
     %a = 3
   }
}

test1 = ::{
  %a = 3
}

a = 0
x = test1
I x.a==3 and a==0

//---------------
// We discarded long time ago, weird "= foo ". Uncommon in other lang
test1 = ::{
  %a = 3
}

a = 0
= test1
I a==3

//--------------
test1 = ::{
  %a = 3
}

a = 0
test1
I a==3

-------
map as ::{
  t = ()
  fun = $.__block
  for a in $ {
    t ++= fun(a)
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (1 2 3) |> map ::{$+1} |> map ::{$*$}
I s == (4 9 16)

-------
map as ::{
  t = ()
  fun = $.__block
  for a:$ {
    t ++= fun a
  }
  return t
}
a = ::{ 2+1 }  // OK implicit return
// parse error, only last can be implicit return
//a = ::{ 1+1 ; 2+1 }
s = (x 2 3) |> map ::{$+1} |> map ::{$*$}
I s == ((x+1)*(x+1) 9 16)

// TODO: This is a compile error (# inputs is unknown at compile time)
s = $x ** (1 2 3) |> map ::{$+1} |> map ::{$*$}


==========================
CHISEL example library (PrefixSum) to do tree reduction

prefix_reduction = ::{
  total = $0
  for i in $[1..] {
    total = $.__do(total,i)
  }

  return total
}

total = (1 2 3 4) |> prefix_reduction ::{ $0 + $1 }

------
Go over KoggeStoneAdder in CHISEL and do the equivalent in Pyrope to see
(Latchup.io Jack talk on CHISEL 3)

------
Go over sparse prefix sum in CHISEL and Pyrope

------
Add example:

doadd = ::{ $0 + $1 }
reduce = ::{
  total = $1
  for i:$[2..] {
    total = $0(total, i)
  }
  return total
}
total = (1 2 3 4) |> reduce \doadd
I total == 10

------

dec_large = ::{
  for a in $ {
    if (#[0](a)) {      // #.0 == #[0]
      % ++= #.potato(a) // #.1 == #.potato
    }else{
      % ++= a
    }
  }
}

(1, 2, 3) |> dec_large ::{ $0 > 3 } potato { $0-1 }

