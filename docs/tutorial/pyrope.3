
These are some potential ideas for Pyrope v3 based on RUST/V ideas

 //NOTE: default value must be given to xx "var xx" not OK

 var xx =  // xx should not exist, xx is mutable (if type set, type can not be changed)
 let xx =  // xx should not exist, xx is immutable

 var foo.bar.xx  = // foo.bar should exist , xx should not exist. xx is mutable
 let foo.bar.xx  = // foo.bar should exist , xx should not exist. xx is immutable

 // add var foo.bar.xx  = // foo.bar may exist , xx should not exist. xx is mutable
 // add let foo.bar.xx  = // foo.bar may exist , xx should not exist. xx is immutable

 mut foo.bar.xx  = // foo.bar.xx should exist as mutable
 set foo.bar.xx  = // (only check that foo.bar.xx is not immutable) foo.bar.xx may be mutable or not exist

 x = 3  // immutable x : same as let x = 3
 x += 3 // mutable x : same as mut x = x + 3
%x = 3  // mutable %x output: same as mut %x = 3

 a[xx] = // implies mutable, No need to say mut a[xx]

 mut $foo = 3 // compile error

 comptime mut foo.bar.xx = // comptime -> the rhs/value/tuple to assign must be known at compile time
 comptime raw foo.bar.xx = // ....

 comptime var xx =  // the assignment is comptime, future updates may not be

 // Type style (same object but the object can not affect results, just a variable type

 // Default value must be given to the type "var type xt" not OK

 type xt:xxx  // xt is type and immutable

 var xx:xt = ... // xx is type xt with contructor values of ...
 let xx:xt = ... // immutable version

 // Tuple syntax
 foo = (comptime bar = (mut xx = 3, let yy = 4), zz = 5)

 var lhs = rhs // lhs should not exist, lhs is mutable
 let lhs = rhs // lhs should not exist, lhs is immutable

 mut lhs = rhs // lhs should exist as mutable
 comptime lhs = rhs // rhs must be known at compile time


3.Bit selection

 x= foo@[3]            // pick bit 3 from foo

 x= foo@[1,3]        // pick bits 1 and 3
 x= foo@[0..=-1]     // pick all bits
 x= foo@[0..=]       // pick all bits
 x= foo@[]           // pick all bits
 x= foo@[1..<-1]     //pick all bits but LSB
 x= foo@[1..=-2]     //pick all bits but LSB

 foo@[] == bar@[]  // typecast, get all bits

 tmp = foo@[1..<3]  // tmp.min>=0
 tmp = foo@[]       // tposs 
 tmp = foo@sext[2]  // sign extend from bit 2
 tmp = foo@zext[2]  // == foo@[2]

 tmp = foo@|[]     // or reduction
 tmp = foo@&[]     // and reduction
 tmp = foo@^[]     // xor reduction

4.A bit cleaner assert/assume/ensure

 guard  foo < 3   // Method called only if foo < 3
 assert foo == 3  // compile or runtime check
 ensure foo == 3  // compile time check
 assume foo < 3   // enforced in verif mode
 restrict foo < 4 // constrain to help in verif mode

5.Easier function type check

 XXX equals :YYY // same as (XXX implements :YYY and YYY implements :XXX)

 XX:YY "same as" for each YY var, XX implements it with same type

 XX:YY "could be read as" XX implements YY type (but it can be more)
 XX equals YY "could be read as" XX has the the methods/vars as YY

 XX has YY "could be read as" XX.YYY exists

XX implements :YY // XX can be more than YY (values can be different)
XX equals     :YY // XX exactly the same type as YY (values can be different)
XX

 fun = {||
   ensure $ implements :(foo,bar)
   ensure %.__size == 1
   ensure % is :(sum)

   %sum = $foo + $bar
 }

----
BRAIN DUMP:

iris2 f* use some

type m:my_mem(size=1K, initial="foo.json", xxxx=3);

m.read(port=0,300) {||
  puts "One cycle later, the read is {}", $
}

m.write(port=2,addr=301+x, data=33+a)

type counter:{signed where signed implements :int and signed__bits<4 and signed__min>2 }

let xxx_type:{signed where signed in 7..<23 } = 20

a:unsigned(0..=3) = b:signed(10..=20) - c:xxx_type;


x = Bar :{(a,b) where a.__sbits>6 and b equals Foo}

Base types: int, string

---

Method IOs

foo = {||
  type T:$a  // T is the Type of $a
  type $:(a:T,b:T)
  type %:(sum:T)
}

type $:(a:,b:) // $ is a bundle with a and b fields that have any type "foo:" is a type def without type
---

Argument name match

fun1 = {|(a,b)| ... $a ... $b ...}
fun2 = {|| ...$a...$b...}
fun3 = {|| ...$0...$1...}
fun4 = {|(a)| ... $a.complex.tuple...} // LL may expand to a.complex.foo a.complex.bar

a = 1
c = 2

xx = fun1(a,b=c) // OK: if no name provided b=, try to match the current variable name
xx = fun1(a,c)   // compile error

xx = fun2(a,b=c) // OK: if no name provided b=, try to match the current variable name
xx = fun2(a,c)   // compile error

xx = fun2(a,b=c) // compile error, no b defined
xx = fun2(a,c)   // OK, just position based

xx = fun4(a=zz) // OK
xx = fun4(a)    // OK
xx = fun4(a)    // OK
xx = fun4(a.complex=zz)    // compile error

xx = fun4(a=(complex=zz)) // OK

---

6.Explicit import keyword

 Cleaner than current lgcpp current call

 x   = import foo.potato (bar, mod3)
 tot = import another.thing

 x.bar(3,4)
 11 |> x.mod3
 tot(3)

-Maybe make punch/import consistent. The diff is that import gets only methods and compile error if multiple match

 x = import([top], "foo.potato.(bar|mod3)") // match with regex like punch
 y = punch("any_wire_named_foo")
 for i in y {
   puts("wire:{} has value:{}\n", i.__key, i);
 }

7.If allowed to have a return

 s = if cond & 1 { (odd=1, 33) } else { (odd=0, bar+3) }

8.Tuple/Type check

 a = 3
 assert a is :1030

 b = (c=3,d=4)
 assert b equals :(c=0,d=0)   // value does not matter
 assert b not equals :(d=0,c=0)  // ordered tuple
 assert b implements :(c:,d:)   // syntax sugar for (c=0,d=0)

 process_tree = {|
   assert $ implements :(left:,right:,value:) or implements :(value)
 }

9.Init for modules/directories

__reset = :{
}

10.Allow read-only definition time scope variables capture (ONLY if the
definition variable is immutable )

a = 3
let foo = 10

do_xx = :{ return foo+$0 }

res1 = do_xx(2)
assert res1 == 12

foo = 3

res2 = do_xx(2)
assert res1 == 12

11.Enums

 Current:

 color.__allow = ('red', 'green', 'blue')
 assert color is :(red=0, green=1, blue=2)

 Some syntax sugar a bit Elixir style?
 Allow :foo the same as 'foo'

12.Autodoc

 Use the vow AND prp to generate doc. Use comments like v/go/doxygen and parse
the assertions/assume

13.All variables have initial value but "undefined" is valid assign
 (this was already in Pyrope 2, but not well documented)

 mut foo = undefined
 assert foo>3 // fails
 foo = 4


13.Trait/objects


-Abstract class or trait

  type Shape = (
    ,name = {|() -> (_:string)|}
    ,area = {|() -> (_:i32)|}
    ,increase_size = {|mut (_:i12) -> ()|}
  )

  type Circle:Shape = (
    ,rad:i32
    ,name = {|() -> (_:string)| return "circle" }
    ,area = {|() -> (_:i32)|
       let pi = import("math.pi")
       return pi * self.rad * self.rad
    }
    ,increase_size = {|mut (_:i12) -> ()| self.rad *= $ }
  )

============================================

Why not generics?

 -In Pyrope, every method is a generic. The assert/assume/restrict constrain the generic


14.Future types

 type Int = (
   ,__initial = {|mut (a:range)|
     self.__max = a.max when a.max_set
     self.__min = a.min when a.min_set
     assert a.step==1, "Integer type only deals with ranges without steps"
   }
 )

 type txxx =int(-10..<_)
 type txx  =int(-10..=50)

 var x:txxx = 0
 let x:txx = 33
 mut x = 3 // preserve type

 x = (a:txx=3,b:foo=5)

 I(x equals :(a:txx,b:foo))
 I(x equals :(a:_,b:foo))
 I(x not equals (a:foo))

 int(0..=22) // min:0 max:22
 int(_..=22)  // min:-inf, max:22
 int(3..<_)   // min:3 max:inf
 string
 bool

 xx = {|(a:int(0..=44)|
 }

 xx(a=3) // OK
 xx(a=50) // compile error

 var x:int(0..=30)=0
 assert x not equals :int(0..=50)
 assert x not implements :int(0..=50)
 assert x not equals :int(0..=5)
 assert x implements :int(0..=5)  // subset

The "A equals B" type check:

1st-Exactly the same fields in A and B
2nd-Each field has the same basic type (int/bool/string/range)
3rd-Attributes should match too (A.__max == B.__max, __reset ...)
4th-__where statement should LEC to be A.__where == B.__where

The "A implements B" type check:

1st-Any field in B is present in A (matching fields)
2nd-Each matching field has the same basic type (int/bool/string/range)
3rd-For matching attributes too (A.__max <= B.__max, A.__reset == B.__reset ...)
4th-__where statement should LEC to be A.__where implies B.__where


15.Memory API


 //----------------------
 // RAW direct flop and memory


 ff = __flop(clock=$clk, din=xx)
 // ff is the flop_q pin

 // 1 rd and 1 wr port
 mm = __mem(entries=1K, bits=30, mode=(0,1) addr=(rd_addr, wr_addr), enable=(rd_enable, wr_enable), data_in=(0,wr_data))
 mm = __mem(entries=1K, bits=30, mode.0=0, mode.1=1, addr.0=rd_addr, addr.1=wr_addr, enable.0=rd_enable, enable.1=wr_enable, data_in.1=wr_data)

 xx = mm.Q  // result from addr.1
 //----------------------

 a = mem(entries=4K, rd_ports=3, wr_ports=4, entry_bits=32, posedge=false)

 a.write(addr=20,data=30) // generic multiport API
 x = a.read(33)

 a.wr[0].write(addr=20,data=30)
 a.rd[1].read(addr=20)
 a.wr[1].write(wmask=0xF0, addr=500, data=11)

 mem = {|
   n_ports = $rd_ports + $wr_ports

   addr_list = () // First writes, then reads
   mode_list = ()
   data_in_list ()
   for i in 0:(wr_ports-1) {
     data_in_list ++= xx.wr[i].data_in.__last_value
     addr_list    ++= xx.wr[i].addr.__last_value
     mode_list    ++= (1)
   }
   for i in 0:(rd_ports-1) {
     data_in_list ++= (0)
     addr_list    ++= xx.rd[i].addr.__last_value
     mode_list    ++= (0)
   }

   let my_clock = this.clock

   xx = __mem(clock=my_clock, entries=$entries, bits=$entry_bits, addr=addr_list, enable=enable_list, clock=clock_list, data_in=data_inst_list, mode=mode_list)
   for pid in 0:(wr_ports-1) {
     xx.wr[pid].write = {|
       this.data_in = $data
       this.addr    = $addr
     }
   }
   for pid in 0:(rd_ports-1) {
     xx.rd[pid].read = {|
       this.addr = $addr
       return this[".."][".."].q[pid] // xx.q[pid] // foo.bar.jojo[".."] == for.bar
     }
   }

   for pid in 0:(rd_ports-1) {
     xx.rd[pid].read_pipe = {|
       yy = ()
       for i in $ {
         yy[i.__key] = __flop(clock=my_clock, din=i)
       }
       this.addr = $addr
       yy.addr   = __flop(clock=my_clock,$addr);
       yy.q = this[".."][".."].q[pid]
       $.__do(yy)
     }
   }

   return xx
 }

 mem.rd[0].read_pipe(addr=10,meta_1=(x=1,b=4)) {|
   // Method called a cycle later (when read is done)
   puts("read to addr:{} has data:{} with meta.x={}\n",$.addr, $data, $meta.x);
 }

 //----------------------

 my_custom_flop = {|

   let ff.q   = __flop(din=ff.din.__last_value, enable=ff.enable.__last_value, initial=$initial)

   ff.din     = 0 // clear din every clock cycle
   ff.enable  = false

   ff.write = {|
     this.enable = true
     this.din = $
   }

   ff.read = {|
     return this.q
   }

   ff.read_pipe = {|
     xx = ()
     for i in $ {
       xx[i.__key] = __flop(din=i)
     }
     xx.din = this.q
     $.__do(xx)
   }

   return ff
 }

 ff = my_custom_flop(initial=0)

 val_q = ff.read()
 ff.write(33)

 ff.read_pipe(vv=$runtime) {|
   val = $din // must be 33 next cycle
   // $vv == last cycle $runtime
 }

 ff.read_pipe(foo=3) {|
   val = $din // must be 33 next cycle
   // $foo== 3
   // $vv == last cycle $runtime
 }

--------------


Allow at pyrope (not lnast) more intuitive ops. Like

If a in x {
If a not in x {

If a between 2: {
It a between 3:8 {

A = x if condition
A = (3 if cond else 5)

a = 3 if foo else 5

mut a = 3 if boo else 5 if cond // WEIRD!

mut a = match foo { case true {3}, else {5} } when cond

OPT = 1
match tup_expr {
  in 1,3,4       { puts("1..4, not 2 it was:{}", tup_expr }
  in 55 when OPT { puts("55 and OPT true")                }
  in 33          { puts "{} is less than 33", tup_expr    }
  else           { puts("Something else {}", tup_expr)    }
}

match foo+2 {
  in (1,2,3) { ... }
  0b???0 { ... }
  0b1?00 when foo+2>100 { ... }
}

// same as
unique if tup_expr in (1,2,3) {
  puts("1..4, not 2 it was:{}", tup_expr
}elif tup_expr in 55 and OPT {
  puts("55 and OPT true")
}elif tup_expr in  33 {
  puts "{} is less than 33", tup_expr
}else {
  puts("Something else {}", tup_expr)
}

match xx {
  is :signed(1:3) { .. }
  is :bool        { .. }
  else { .. }
}

// single expr inside { } when assigning statement

a = match cond { in true {123} else {33} }

a = (a?3:4)
a = (if a {3} else {4}) when cond3


if cond {
  puts "hello here"
}elif cond2 {
  //
}else{
  puts("xxx")
} when disable_condition

One line:
  let a = 3 unless enable_stuff
Expands to:
  tmp = undefined
  if enable_stuff {
    tmp = 3
  }
  let a = tmp


Python style comprehension (no nested no walrus)
A = (1<<i for I in 1:10)

PYTHON:
>>> sentence = 'the rocket came back from mars'
>>> vowels = [i for i in sentence if i in 'aeiou']
>>> vowels

OPT 1:
sentence = 'the rocket came back from mars'
vowels = ()
for i in sentence {
  if i in ('a','e','i','o','u') {
    vowels = vowels ++ i
  }
}

OPT 2:
filter = {|
  res = ()
  for i in $ {
    if $.__do(i) {
      res = res ++ i
    }
  }
  return res
}
let vowels = sentence |> filter {| $ in 'aeiou') }

OPT 3: (NOT IMPLEMENTED. Same as OPT 2, and less syntax to support)
let vowels = (i for i in sentence if i in 'aeiou')

_------
1..3 == 1:2


----------------------------------

add = ({| true }, {| $0+$1})
add ++= ({|$0.bits==1}, {| my_fast_plus_1_add($0,$1) })


xxx = (1,2) |> pick(add)

A.foo  = {| }
a.foo ++= {|(a:,b:)|...
A.foo ++= {|((a:,b:)->(c:) where a<b|...

When a matching method is found, that method is called.

Diff is that the overload tracking is a variable/ordered tuple. It goes one entry at a time to decide the call.

To allow multiple case at compile time.

A.foo.__runtime_select = false
In pyrope
x = runtime A.foo(a,b) // mux of fcalls allowed
comptime x = a.foo(a,b) // default
Runtime x = ... // Default
Comprime x = ... // Result x know at compile time can be mut or let or var...


comptime let xx = fun(args)


y = add(x,1)
// Is y combinational or flopped??
// assert y == (x+1)
// assert y == (past(x)+1)

add = {| $0+$1 }
padd = {|
  %    = @res
  @res = $0+$1
}

let comb y = add(x,1) // checks that add is pure comb
assert y == x+1

let pipe y = padd(x,1) // checks that outputs are not pure comb
assert y == past(x)+1 // x is from past

assert #y1 == past(x)+1
let pipe  y2 = add(x,1)
assert #y1 == y2
let comb #y1 = add(x,1)
maybe #y1 != y2

--------------

// coverage guided assertions (lgcpp)

cover var  // any possible value of var should be tested
cover var, reset=true // include reset in coverage
cover var, range=(1..3) // cover from just 1..3
cover(var, range=(1,30,2)) // cover var just 1,2, and 30 values

--------------


for i in 1,3,4 {
}

a = 1..33 step 4
a = 1:33 step 4


---------------------

any = {|
  for i in $ {
    if $.__do(i) {
      return true
    }
  }
  return false
}

all = {|
  for i in $ {
     $.__do(i)
    return false unless res
  }
  return true
}

comptime if any(2,7,3) {| $ < 3} {
}

if (1,2,3) |> all {| $ <= 3} {
}

------------------------------

Some feedback from zig:

1-Multiline string literals

  c =
  \\ foo is bar
  \\because I think so  
  \\what

This means that we do not have anything (but comments) that go multi-line.  Zig
allows "each line can be tokenized in parallel". Zig removes multiline
comments.

2-comptime code segment

 comptime a = 3
 comptime { //new scope
   a = 3
 }

3-test code blocks

test "bla bla bla " {
  // test something here
}

vow "bla bla bla" {
  // verification/monitor support
  xx = a + 1
  sink xx // value visible for monitors (push as IO?)
}

--------------------------------

No RAII?? (must have constructor/destructors to support)

--------------------------------

Lambdas should be allowed to capture by value 
```
auto make_function(int& x) {
  return [x]{ std::cout << x << '\n'; };
}

int main() {
  int i = 3;
  auto f = make_function(i); // the use of x in f binds directly to i
  i = 5;
  f(); // OK; prints 3
}
```

Equivalent in Pyrope:

```
make_function = {|
  x = $0
  % = {| puts("{}", punch("x")) }
}

i = 3
f = make_function(i)
i = 5
f() // prints 3
```

---------------

punch vs import

Both start search from current module, going up in hierarchy

- punch connects values
- import connects methods

punch vs peek???

- punch connects through modules (test and/or synthesis)
- peek is during simulation/test to see a value??? 

How to connect output?? (Can we?)

- poke during testing
- compile time??

--------------------------------
vow/test scope/test?

if $enable {
  @counter += 1
}

test "ba ba" {
  // statements added before to drive this block
  // Given in BDD (before the code block)
  $enable = 0
  tmp = @counter

  expect { // statements added at the end (same cycle)
    assert tmp == @counter

    yield // wait 1 cycle

    assert tmp == @counter
  }
}
This generates a module_list this:

  $enable = 0
  tmp = @counter

  if $enable {
    @counter += 1
  }

  assert tmp == @counter

  yield

  assert tmp == @counter

test "ba ba2" {
  expect {
    assert @counter == 4
  }

  $enable = 1

  expect {
    puts "done"
  }
  @counter = 3
}

Generates 2 tests (2 expects):
 
  $enable = 1
  @counter = 3

  if $enable {
    @counter += 1
  }

  assert @counter == 4

AND ALSO:

  $enable = 1
  @counter = 3

  if $enable {
    @counter += 1
  }

  puts "done"

-------------------
Some object ideas:

type canine  = (
   ,bark:def
   ,field:{(__bits =3, __initial=0) where  $ < 4 }
)

type Dog:Canine
Dog.bark = {|
}

Dog.field3 = ....

Dog.__initial = {|
  self.field3 = $0
  puts "second constructor argument is {}", $1
}

let xx:Dog(1,2)

-------------------------


yield 3 {
  puts "here we are {}", potato
} when a.__bits > 3


// val = 0,1,2,3
assert val#[-1] == 1 and val#[-2] == 0 when val==2

let async a = fcall_1pipe_add_3(val)
let pipe  b = fcall_1pipe_add_3(val)
let       c = val + 3 // combinational

d = fcall_1pipe_add_3(val) // compile error (fcall is pipelined)

await a { // async, flops live-ins as needed
  assert val==0 and a==3 and c==3 // evaluated 1 cycle later (one cycle c is computer, but c is flopped like val)
      or val==1 and a==4 and c==4
      or val==2 and a==5 and c==5
      or val>2
}

foo = a + b // compile error. "a" must be inside an await block

assert val==0 and c==3 // evaluated at the same time than c is computed
    or val==1 and c==4
    or val==2 and c==5
    or val>2

// pipe just wires, you "known" how to deal with pipeline stages
assert val==0 and b==0b? // evaluated same cycle as c is computed
    or val==1 and b==3
    or val==2 and b==4
    or val>2

yield { // flop all live-ins
  assert (val==0 and a==3) or reset#[-1] // same as before but checked 1 cycle later
      or val==1 and a==4
      or val==2 and a==5
      or val>2

  assert val==0 and c==3 // evaluated 1 cycle later (yield 1)
      or val==1 and c==4
      or val==2 and c==5
      or val>2

  assert val==0 and b==0b?
      or val==1 and b==3
      or val==2 and b==4
      or val>2
}


---------------------------------------------
Verilog inline: case 1

// filename: myfile

var verilog = "module do_add(\n"
verilog   ++= "  input signed [31:0] a\n"
verilog   ++= " ,input signed [16:0] b\n"
verilog   ++= " ,output reg [32:0] out);\n"

verilog   ++= " always @(*) begin\n"
verilog   ++= "   out = a + b;\n"
verilog   ++= " end\n"
verilog   ++= "endmodule\n"

lg = import "livehd"
comptime lg.pass.compile(verilog)

tmp = do_add(3,4)
assert tmp == 7

---------------------------------------------
Verilog inline: case 2

comptime genTable = {|
  rnd = import "util.rand"

  var arr = ()
  for a in 0..1024 {
    arr[a] = rnd(0..256)
  }

  return arr
}

comptime genTable_verilog = {|

  var verilog = "module my_genTable_verilog(\n"
  verilog   ++= "  input [9:0] addr\n"
  verilog   ++= " ,output reg [7:0] data);\n"

  verilog   ++= " always @(*) begin\n"
  verilog   ++= "   case(addr)\n"

  rnd = import "util.rand"
  fmt = import "string.fmt"

  for a in 0..1024 {
    verilog   ++= fmt("  {}:{};\n", a, rnd(0..256))
  }

  verilog   ++= "     default: data = 0;\n"
  verilog   ++= "   endcase\n"
  verilog   ++= " end\n"
  verilog   ++= "endmodule\n"

  lg = import "livehd"
  lg.pass.compile(verilog)
}

rom = genTable()
%data1 = rom[$addr]

genTable_verilog()

out = my_genTable_verilog(addr=$addr)
%data2 = out.data

//--------------------------------------------

a = 1

// Using default bundles
fun1 = {|$=(b:,c:) capture(a) -> (ret1)| ... }

// C++ like syntax
fun2 = {|[a]<T>(b:T,c)-> (ret1)| ... }

fun2<myT>(b=3,c=4)

// Captures with code blocks
fun3 = {|[a](b)-> [do](ret1)| %ret = do(a,$b) }

xx = fun3(b=2) {|| $0 + $1 }
assert xx.ret == (1+2)

// How to capture a $bar

{
  tmp = $bar
  fun4 = {|[tmp](a,b)->(c)|
     %c = tmp + $a + $b
  }
}

fun4 = {|[tmp=$bar](a,b)->(c)|
   %c = tmp + $a + $b
}

//--------------------------------------------

fun1 = {|| $0 + $1 } // no args no where
fun2 = {|(a,b,c)| $a + $.b | $['c'] } // 3 args
fun3 = {|(a,b,c) where $c<10| $a + $.b | $['c'] } // 3 args where c<10

fun = fun1 ++ fun2 ++ fun3

fun(1,2)     // calls fun1
fun(1,2,300) // calls fun2
fun(1,2,3)   // calls fun3


//---------------------------

All caps is a unique ID

let type states:{x where x in (ONE, TWO, THREE)} = ONE



if a = ONE


//--------------------------------------------
mut/let/set/var translation to LNAST

Orig:
  var foo = ....
Becomes:
  assert(foo is undef, "foo is previously defined")
  foo = ...

Orig:
  var foo.bar = ....
Becomes:
  assert(foo.bar is undef, "foo is previously defined")
  foo.bar = ...

Orig:
  let foo = ...
Becomes:
  assert(foo is undef, "foo is previously defined")
  foo = ...

Orig:
  let foo.bar = ...
Becomes:
  assert(foo.bar is undef, "foo.bar is previously defined")
  foo.bar = ...

Orig:
  mut foo = ...
Becomes:
  assert(foo is def, "foo is not previously defined")
  foo = ...

Orig:
  mut foo.bar = ...
Becomes:
  assert(foo is def, "foo is not previously defined")
  assert(foo.bar is def, "foo.bar is not previously defined")
  foo.bar = ...

Orig:
  set foo = ...
Becomes:
  foo = ... // no checks

Orig:
  set foo.bar = ...
Becomes:
  assert(foo is def, "foo is not previously defined")
  foo.bar = ...
---------------------------------

TO FIX?

1-dot in args

xx = fun4(a=(complex=zz)) // OK
xx = fun4(a.complex=zz)   // compile error (WHY NOT?)

2-simplified fcalls rule
xx = method foo.bar,"asss"
mut xx = method foo.bar,"asss"

3-regex?

xx = import //foo.bar.*//

// go to top directory, try to match xx dir, then bar mod, then a* outputs.
// If no match, go down a path up to reaching current directory, with xx sub and bar mod
foo = /xx.bar.a*/.import

// Similarly but go through hierarchy (not directories)
foo = /xx.bar.a*/.connect


----------------------------------------------
Inline lambda

- Captures as needed unless [] restrict to nothing to capture?

var a = 1

{
  mut a = 3
}

{|->(a)| // only 'a' as output
  mut a = 3
}

{|| // unconstrained output[s]
  %a = 3

  // The diff with {|| vs {  is that the % and $ are changed to current lambda scope
}

//-------------------------

if cond {|(x) -> (a)|
  %a = $x // or "mut a = x" or "%a = x"
}

if cond {
  mut a = x
}

//-------------------------

var a=1
a += 2
a += xx

var a=1
a += 2
{|[xx]->(a)|
  a += xx
}

//-------------------------

var x = 3 + {|| var v = 3 ; % = b/2 } /3

if {|[x]| var tmp = x+3 ; return fcall(tmp) or fcall2(tmp)} {
  puts "hello"
}
